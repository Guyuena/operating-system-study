<img src="C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20230220093110741.png" alt="image-20230220093110741" style="zoom:67%;" />





<img src="C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20230220093131840.png" alt="image-20230220093131840" style="zoom:67%;" />

<img src="C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20230220093149072.png" alt="image-20230220093149072" style="zoom:67%;" />

<img src="C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20230220093210271.png" alt="image-20230220093210271" style="zoom:67%;" />

<img src="C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20230220093226324.png" alt="image-20230220093226324" style="zoom:67%;" />

<img src="C:\Users\jc\AppData\Roaming\Typora\typora-user-images\image-20230220093243727.png" alt="image-20230220093243727" style="zoom:67%;" />

https://www.zhihu.com/question/20793038







- **指令集与机器码**

无论处于上层的软件多么的高级, 想要在CPU执行, 就必须被翻译成"机器码", 翻译这个工作由[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)来执行. 编译器在这个过程中, 要经过"编译", "汇编", "链接"几个步骤, 最后生成"可执行文件". 可执行文件中保存的是二进制机器码. 这串机器码可以直接被CPU读取和执行.

**软件意义上, "指令集"实际上是一个规范, 规范汇编的文件格式.**
以下为一条x86汇编代码:
mov word ptr es:[eax + ecx * 8 + 0x11223344], 0x12345678

这里可以体现出指令集的格式限制:
\1. 可以使用mov指令, 但它只能有2个操作数.
\2. 它的操作数长度是16 (word), 不要看到后面0x12345678就认为是32位操作数.
\3. 它带有段超越前缀, 这里使用了es, 还可以使用ds, cs, ss, fs, gs. 但是只能用这几个.
\4. 第一个操作数是一个内存地址, 第二个是立即数. 但是, 这个内存地址不能乱写, 写成[eax+ecx*10+0x11223344]就错了.

实际上, **一条汇编指令与一段机器码是一一对应的.** 上面这段汇, 可以被x86编译器翻译成几乎唯一的一段机器码:
26 66 c7 84 c8 44 33 22 11 78 56
上面提到的1,2,3,4点如果有一个弄错, 这一步就会失败.

可以看出来, 指令集的作用, 就是告诉程序员/编译器, 汇编一定要有格式. 支持什么指令, 指令带什么限制条件, 用什么操作数, 用什么地址, 都是指令集规范的内容, 要是写错了, 就无法翻译成机器码.
指令集规范汇编, 汇编可以翻译成机器码, 机器码告诉CPU每个周期去做什么. 因此, **CPU指令集是描述CPU能实现什么功能的一个集合, 就是描述"CPU能使用哪些机器码"的集合".**

那机器码进入到CPU后又做什么呢?
=====================编译器和CPU的分界线========================

需要被执行的机器码先要被OS调度到内存之中, 程序执行时, 机器码依次经过了Memory--Cache--CPU fetch, 进入CPU流水线, 接着就要对它进行译码了, 译码工作生成的象是CPU内部数据格式, 微码(或者类似的格式, 这个格式不同的厂商会自己设计).

这个过程画成图就是:

软件层: 汇编语言
\------------------------------------------------------------------------
接口: 汇编语言所对应的机器码
\------------------------------------------------------------------------
硬件层: CPU使用内部数据结构进行运算

如果机器码代表的功能是在指令集规范内的, 这条机器码就可以生产微码, 并在CPU内正常流动. 假设机器码是错误的, 是不可以通过CPU的译码阶段的, 控制电路一定会报错. 这种情况反映在Windows里往往都是蓝屏, 因为CPU无法继续执行, 它连下一条指令在哪都不知道.

**那么指令集在CPU里就代表: 只有CPU指令集范围内的指令可以被成功的译码, 并送往CPU流水线后端去执行.**
**和常规的想法不一样, CPU不需要任何形式的存储介质去存储指令集, 因为"译码"这个步骤就是在对指令集里规范的机器码做解码. 硬件上, 译码这件事需要庞大数目的逻辑门阵列来实现.**

跳出格式这个圈子来看待这个问题. 可以说, CPU执行单元的能力, 决定了指令集的范围. 比如, CPU的执行单元有能力执行16位加法, 32位加法, 64位加法, 那么指令集里**一般**就会有ADD 16, ADD 32, ADD 64这样的表达方式. 如果CPU的执行单元没有电路执行AVX指令, 那么指令集里**一般**就没有VINSERTF128这样的指令供使用. 所以, 强有力的执行单元能够提供更多的指令集.

再来看"CPU指令集在哪里"这个问题, 回答是, **CPU本身就是CPU指令集**. 指令集规定CPU可以做什么事, CPU就是具体做这件事的工具. 如果一定要指定一个狭义的CPU指令集的存放位置. 那就是CPU中的"译码电路".

 

- **对于指令集的电路理解**


现代的CPU没拆过，我只在计算机组成原理实验课上用VHDL在某个实验平台上做过一个模拟的CPU。举个例子你可能比较好理解。
比如我们设计一套指令集，其中肯定有条加法指令。比如Add R1 R2 。我们可以认为这条指令的意思是计算寄存器R1中的内容和R2的和，然后把结果存到R1寄存器中。
那么经过编译后这条指令会变成[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)，比如010100010010 。这条二进制指令一共12位。明显可以分为三大部分。最前面的0101表示这是条加法指令，后面0001说的是第一个操作数是寄存器1，最后0010说的是第二个数就是寄存器2（其实实际没有这么简单的指令，至少应该区分操作数是寄存器还是直接的数据，但为了把这说的更容易理解作了简化）。我们可以通过十二根导线把这条指令输入一个CPU中。导线通电就是1，不通电就是0 。为了叙述方便我们从左到右用A0-A11给这12根导线编上号。
然后计算机会分析这条指令。步骤如下：

1. 最开始的两根导线A0和A1，第一根有电第二根没电，就能知道这是一条运算指令（而非存储器操作或者跳转等指令）。那么指令将被送入逻辑运算单元（ALU）去进行计算。其实很简单。只要这两根线控制接下来那部分电路开关即可。
2. 接下来的A2和A3，01表示加法，那么就走加法运算那部分电路，关闭减法等运算电路。
3. A4-A7将被送入寄存器电路，从中读取寄存器保存的值。送到ALU的第一个数据接口电路上。
4. 后面的A8-A11同样被送入寄存器选择电路，接通R2寄存器，然后R2就把值送出来，放到ALU的第二个数据接口上。
5. ALU开始运算，把两个接口电路上的数据加起来，然后输出。
6. 最后结果又被送回R1。

基本上简单的运算计算机就是这么操作的。他其实不知道你那些指令都是什么意思。具体的指令编程机器码后就会变成数字电路的开关信号。其中某几段会作为控制信号，控制其他部分的数据走不同的电路以执行运算。他没有一个地方保存着如何翻译这些机器码的字典，所有机器码的意义都被体现在整个电路的设计中了。
当然，从汇编到机器码这步是汇编程序翻译的。汇编程序当然知道某条指令要翻译成什么样的机器码。

 

- **总结**

**对于指令集的简单理解，它就是CPU中一堆实现各种计算的逻辑门电路，支持执行很多格式的机器码。**

**而指令集，就是对CPU支持的机器码格式规范的一个描述。**

引用原作者的理解：

**软件意义上, "指令集"实际上是一个规范, 规范汇编的文件格式。**

**CPU指令集是描述CPU能实现什么功能的一个集合, 就是描述"CPU能使用哪些机器码"的集合"。**







# 处理器架构

1. 处理器架构就是处理器的硬件架构，称为微架构。是一堆硬件电路，去实现指令集所规定的操作运算。
2. 是的，指令集决定了处理器的架构，因为处理器架构就是用硬件电路实现指令集。但是具体用什么样的处理器架构，设计怎样的硬件电路，每个人设计的都可以不一样。





# 指令集

计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统



# X86

一切都要从 1978 年说起，英特尔在这年发布了世界上第一款 x86 指令集架构的处理器「Intel 8086」。

![img](https://inews.gtimg.com/newsapp_bt/0/11297918209/1000)

之后这个系列的处理器名称都以数字 86 作为结尾，比如 Intel 8086、80286、以及 80486，所以慢慢的这个系列就被简称为 **x86** 了。

x86 从 1985 年发布的 Intel 80386 处理器开始使用「32 位架构指令集」，**称之为 x86_32**（此前都是 16 位）。

随着 Intel 不断推出新的 32 位处理器，慢慢大家发现 32 位 和 x86 通常指的都是一个东西，**所以 32 位也被****简称为 x86。**





# X64

AMD 在 2003 年突然一个鲤鱼打挺，抢在英特尔之前发布了 64 位处理器，并将其命名为「AMD 64」，从此**x86**正式进入了 64 位的时代。

64 位不光数字上领先 32 位，在**性能和应用场景**上也得到了大幅提升（后面讲），之后英特尔也跟进推出了与之兼容的处理器，命其为「Intel 64」，两者被**统称为 x86_64。**

历史的经验告诉我们，懒癌不是能接受 x86_32 和 x86_64 这种说法的，于是**x86_64 被简称成了 x64。**



在硬件上，32 位 软件和 64 位 最大区别，也是当年 64 位被推上舞台的原因，32 位支持的内存是 ，也就是**最大只支持 4GB 内存。**而 64 位支持 2＾64 Byte，也就是 17179869184G=16777216TB ≈ ∞。

64 位处理器解决了内存地址总线的问题。





# ARM

**Advanced RISC Machine**

ARM架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于行动通讯领域，符合其主要设计目标为低耗电的特性



# RISC

RISC（Reduced　Instruction　Set　Computer，[精简指令集计算机](https://baike.baidu.com/item/精简指令集计算机/661859?fromModule=lemma_inlink)）

　RISC的英文全称为“Reduced Instruc[TI](http://bbs.elecfans.com/zhuti_715_1.html)on Set Computer”，即“精简指令集计算机”，是一种执行较少类型计算机指令的微处理器，起源于80年代的MIPS主机（即RISC机），RISC机中采用的微处理器统称RISC处理器。这样一来，它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。



性能特点一：由于指令集简化后，流水线以及常用指令均可用硬件执行； 

性能特点二：采用大量的寄存器，使大部分指令操作都在寄存器之间进行，提高了处理速度； 

性能特点三：采用缓存—主机—外存三级存储结构，使取数与存数指令分开执行，使处理器可以完成尽可能多的工作，且不因从存储器存取信息而放慢处理速度











# CISC

[CISC](https://baike.baidu.com/item/CISC/1189443?fromModule=lemma_inlink)（Complex　Instruction　Set　Computer，复杂指令集计算机）

### CISC的概述

　　复杂指令系统计算机（ComplexInstructionSetComputer）简称(CISC),是一种微处理器指令集架构（ISA），微处理器是台式计算机系统的基本处理部件，每个微处理器的核心是运行指令的电路。指令由完成任务的多个步骤所组成，把数值传送进寄存器或进行相加运算。这些指令被称为微理器的微代码(microcode)，不同制造商的微处理器有不同的微代码系统，制造商可按自己的意愿使微代码做得简单或复杂。指令系统越丰富，微处理器编程就越简单，然而，执行速度也相应越慢。



### CISC的优点

　　1.指令格式不固定,指令可长可短,操作数可多可少.

　　2.寻址方式复杂多样，操作数可来自寄存器,也可来自存储器.

　　3.使用微代码,指令集可以直接在微代码记忆体(比主记忆体的速度快很多)里执行.

　　4.允许设计师实现CISC体系机器的向上相容.新的系统可以使用一个包含早期系统的指令超集合.

　　5.微程式指令的格式与高阶语言相匹配,因而编译器的设计较简单.

　　6.CPI>5,指令越复杂,CPI越大.



### CISC的缺陷

　　1.指令使用频度不均衡."80~20"的理论,80%的计算任务只需要调用20%的指令就能完成; 扩充的复杂指令往往是低频度指令.

　　2.大量复杂指令的控制逻辑不规整.不适于VLSI集成,微程序的使用反而制约了速度提高.

　　3.CISC指令的格式长短不一，需要不同的时钟周期来完成.执行较慢的指令将影响整台机器的执行效率.不利于采用先进指令级并行技术.

　　4.软硬功能分配．复杂指令增加硬件的复杂度，使指令执行周期大大加长，直接访存次数增多，数据重复利用率低

### CISC发展

CISC是指复杂指令系统计算机(ComplexInstructionSetComputer)。这里的计算机指令系统指的是计算机的最低层的机器指令，也就是CPU能够直接识别的指令。随着计算机系统的复杂，要求计算机指令系统的构造能使计算机的整体性能更快更稳定。最初，人们采用的优化方法是通过设置一些功能复杂的指令，把一些原来由软件实现的、常用的功能改用硬件的指令系统实现，以此来提高计算机的执行速度，这种计算机系统就被称为复杂指令系统计算机，即ComplexInstructionSetComputer，简称CISC。另一种优化方法是在20世纪80年代才发展起来的，其基本思想是尽量简化计算机指令功能，只保留那些功能简单、能在一个节拍内执行完成的指令，而把较复杂的功能用一段子程序来实现，这种计算机系统就被称为精简指令系统计算机．即ReducedInstructionSetComputer，简称RISC。RISC技术的精华就是通过简化计算机指令功能，使指令的平均执行周期减少，从而提高计算机的工作主频，同时大量使用通用寄存器来提高子程序执行的速度。

　　从计算机诞生以来，人们一直沿用CISC指令集方式。早期的桌面软件是按CISC设计的，并一直沿用。桌面计算机流行的x86体系结构即使用CISC。微处理器（CPU）厂商一直在走CISC的发展道路，包括Intel、AMD，还有其他一些现在已经更名的厂商，如TI（德州仪器）、Cyrix以及VIA（威盛）等。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。CISC架构的服务器主要以IA-32架构（IntelArchitecture,英特尔架构）为主，而且多数为中低档服务器所采用。





# MIPS

MIPS是世界上很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlocked piped stages)，其机制是尽量利用软件办法避免流水线中的数据相关问题。它最早是在80年代初期由斯坦福(Stanford)大学Hennessy教授领导的研究小组研制出来的。MIPS公司的R系列就是在此基础上开发的RISC工业产品的微处理器



MIPS技术公司是美国著名的芯片设计公司，它采用精简指令系统计算结构(RISC)来设计芯片。和[英特尔](https://xueqiu.com/S/INTC?from=status_stock_match)采用的复杂指令系统计算结构(CISC)相比，RISC具有设计更简单、设计周期更短等优点，并可以应用更多先进的技术，开发更快的下一代处理器。

MIPS是出现最早的商业RISC架构芯片之一，新的架构集成了所有原来MIPS指令集，并增加了许多更强大的功能。MIPS自己只进行CPU的设计，之后把设计方案授权给客户，使得客户能够制造出高性能的CPU



# 处理器架构-指令集-汇编语言三者关系

一、处理器架构就是处理器的硬件架构称为微架构，是一堆硬件电路结构，去实现指令集所规定的操作运算

二、指令集决定着处理器的架构，因为处理器架构就是用硬件电路实现指令集，但具体用什么样的处理器架构怎么样的硬件电路每个设计者都可以不一样的；

三、 sunmakes是一种采取精简指令集rest的处理器架构，既有指令集也有相应的处理器架构，比如龙芯；

四、汇编语言使用人类看得懂的语言来描述指令集，否则指令集的机器码都是一堆二进制数字，人类难以理解，汇编就是用人类语言来描述指令集，读起来就能方便了；



要设计处理器就首先要有指令集来规定处理器的相应操作，通过指令集去控制处理器实现相应的功能，但处理器是一堆硬件电路，只能识别二进制数据，所以指令集是由一堆二进制数据组成，而二进制数据对于人类来说非常难理解，所以发明汇编语言来方便操作指令集；

汇编语言对应一天天指令集，所以当指令集改变就要改变相应的汇编语言，导致其可移植性很差，导致不能跨平台使用，比如ARM的汇编语言和X86的汇编语言就不同；所哟就要超越指令集的语言来方便使用，就有了C，c++，但处理器只能识别二进制语言，所以就有了编译器，将高级语言翻译为汇编语言，汇编语言再翻译成二进制机器码，从而能通过高级语言来控制处理器完成工作。



<img src="https://pic3.zhimg.com/v2-904f5a2a79d9e00d151d101dab23b742_r.jpg" alt="img" style="zoom:67%;" />

